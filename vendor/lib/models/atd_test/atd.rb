# This file was generated by Origen, any hand edits will likely get overwritten
# Created at  9 Jan 2019 09:14AM by jfyh5388
# rubocop:disable all
module ATDTest
  module ATD
    def self.extended(model)
      # ADC Status and Control Registers 1
      model.add_reg :sc1, 0x0, size: 32  do |reg|
        # Conversion Complete Flag
        # 
        # 0 | Conversion is not completed.
        # 1 | Conversion is completed.
        reg.bit 7, :coco, access: :ro
        # Interrupt Enable
        # 
        # 0 | Conversion complete interrupt is disabled.
        # 1 | Conversion complete interrupt is enabled.
        reg.bit 6, :aien
        # Differential Mode Enable
        # 
        # 0 | Single-ended conversions and input channels are selected.
        # 1 | Differential conversions and input channels are selected.
        reg.bit 5, :diff
        # Input channel select
        # 
        # 0 | When DIFF=0, DADP0 is selected as input; when DIFF=1, DAD0 is selected as input. AD0 is selected as input.
        # 1 | When DIFF=0, DADP1 is selected as input; when DIFF=1, DAD1 is selected as input. AD1 is selected as input.
        # 1010 | When DIFF=0, DADP2 is selected as input; when DIFF=1, DAD2 is selected as input. AD2 is selected as input.
        # 1011 | When DIFF=0, DADP3 is selected as input; when DIFF=1, DAD3 is selected as input. AD3 is selected as input.
        # 1100100 | When DIFF=0, AD4 is selected as input; when DIFF=1, it is reserved.
        # 1100101 | When DIFF=0, AD5 is selected as input; when DIFF=1, it is reserved.
        # 1101110 | When DIFF=0, AD6 is selected as input; when DIFF=1, it is reserved.
        # 1101111 | When DIFF=0, AD7 is selected as input; when DIFF=1, it is reserved.
        # 1111101000 | When DIFF=0, AD8 is selected as input; when DIFF=1, it is reserved.
        # 1111101001 | When DIFF=0, AD9 is selected as input; when DIFF=1, it is reserved.
        # 1111110010 | When DIFF=0, AD10 is selected as input; when DIFF=1, it is reserved.
        # 1111110011 | When DIFF=0, AD11 is selected as input; when DIFF=1, it is reserved.
        # 10001001100 | When DIFF=0, AD12 is selected as input; when DIFF=1, it is reserved.
        # 10001001101 | When DIFF=0, AD13 is selected as input; when DIFF=1, it is reserved.
        # 10001010110 | When DIFF=0, AD14 is selected as input; when DIFF=1, it is reserved.
        # 10001010111 | When DIFF=0, AD15 is selected as input; when DIFF=1, it is reserved.
        # 10011100010000 | When DIFF=0, AD16 is selected as input; when DIFF=1, it is reserved.
        # 10011100010001 | When DIFF=0, AD17 is selected as input; when DIFF=1, it is reserved.
        # 10011100011010 | When DIFF=0, AD18 is selected as input; when DIFF=1, it is reserved.
        # 10011100011011 | When DIFF=0, AD19 is selected as input; when DIFF=1, it is reserved.
        # 10011101110100 | When DIFF=0, AD20 is selected as input; when DIFF=1, it is reserved.
        # 10011101110101 | When DIFF=0, AD21 is selected as input; when DIFF=1, it is reserved.
        # 10011101111110 | When DIFF=0, AD22 is selected as input; when DIFF=1, it is reserved.
        # 10011101111111 | When DIFF=0, AD23 is selected as input; when DIFF=1, it is reserved.
        # 10101011111000 | Reserved.
        # 10101011111001 | Reserved.
        # 10101100000010 | When DIFF=0, Temp Sensor (single-ended) is selected as input; when DIFF=1, Temp Sensor (differential) is selected as input.
        # 10101100000011 | When DIFF=0, Bandgap VREF\_OUT (single-ended) is selected as input; when DIFF=1, Bandgap VREF\_OUT (differential) is selected as input.
        # 10101101011100 | Reserved.
        # 10101101011101 | When DIFF=0,VREFSH is selected as input; when DIFF=1, -VREFSH (differential) is selected as input. Voltage reference selected is determined by SC2\[REFSEL\].
        # 10101101100110 | When DIFF=0,VREFSL is selected as input; when DIFF=1, it is reserved. Voltage reference selected is determined by SC2\[REFSEL\].
        # 10101101100111 | Module is disabled.
        reg.bit 4..0, :adch, reset: 0x1F
      end
      # ADC Configuration Register 1
      model.add_reg :cfg1, 0x8, size: 32  do |reg|
        # Low-Power Configuration
        # 
        # 0 | Normal power configuration.
        # 1 | Low-power configuration. The power is reduced at the expense of maximum clock speed.
        reg.bit 7, :adlpc
        # Clock Divide Select
        # 
        # 0 | The divide ratio is 1 and the clock rate is input clock.
        # 1 | The divide ratio is 2 and the clock rate is (input clock)/2.
        # 1010 | The divide ratio is 4 and the clock rate is (input clock)/4.
        # 1011 | The divide ratio is 8 and the clock rate is (input clock)/8.
        reg.bit 6..5, :adiv
        # Sample Time Configuration
        # 
        # 0 | Short sample time.
        # 1 | Long sample time.
        reg.bit 4, :adlsmp
        # Conversion mode selection
        # 
        # 0 | When DIFF=0:It is single-ended 8-bit conversion; when DIFF=1, it is differential 9-bit conversion with 2\'s complement output.
        # 1 | When DIFF=0:It is single-ended 12-bit conversion ; when DIFF=1, it is differential 13-bit conversion with 2\'s complement output.
        # 1010 | When DIFF=0:It is single-ended 10-bit conversion. ; when DIFF=1, it is differential 11-bit conversion with 2\'s complement output
        # 1011 | When DIFF=0:It is single-ended 16-bit conversion..; when DIFF=1, it is differential 16-bit conversion with 2\'s complement output Reserved. Do not set the field to this value.
        reg.bit 3..2, :mode
        # Input Clock Select
        # 
        # 0 | Bus clock
        # 1 | Alternate clock 2 (ALTCLK2) Bus clock divided by 2(BUSCLK/2)
        # 1010 | Alternate clock (ALTCLK)
        # 1011 | Asynchronous clock (ADACK)
        reg.bit 1..0, :adiclk
      end
      # ADC Configuration Register 2
      model.add_reg :cfg2, 0xC, size: 32  do |reg|
        # ADC Mux Select
        # 
        # 0 | ADxxa channels are selected.
        # 1 | ADxxb channels are selected.
        reg.bit 4, :muxsel
        # Asynchronous Clock Output
        # 						Enable
        # 
        # 0 | Asynchronous clock output disabled; Asynchronous clock is enabled only if selected by ADICLK and a conversion is active.
        # 1 | Asynchronous clock and clock output is enabled regardless of the state of the ADC.
        reg.bit 3, :adacken
        # High-Speed Configuration
        # 
        # 0 | Normal conversion sequence selected.
        # 1 | High-speed conversion sequence selected with 2 additional ADCK cycles to total conversion time.
        reg.bit 2, :adhsc
        # Long Sample Time Select
        # 
        # 0 | Default longest sample time; 20 extra ADCK cycles; 24 ADCK cycles total.
        # 1 | 12 extra ADCK cycles; 16 ADCK cycles total sample time.
        # 1010 | 6 extra ADCK cycles; 10 ADCK cycles total sample time.
        # 1011 | 2 extra ADCK cycles; 6 ADCK cycles total sample time.
        reg.bit 1..0, :adlsts
      end
      # ADC Data Result Register
      model.add_reg :r, 0x10, size: 32  do |reg|
        # Data result
        reg.bit 15..0, :d, access: :ro
      end
      # Compare Value Registers
      model.add_reg :cv, 0x18, size: 32  do |reg|
        # Compare Value.
        reg.bit 15..0, :cv
      end
      # Status and Control Register 2
      model.add_reg :sc2, 0x20, size: 32  do |reg|
        # Conversion Active
        # 
        # 0 | Conversion not in progress.
        # 1 | Conversion in progress.
        reg.bit 7, :adact, access: :ro
        # Conversion Trigger Select
        # 
        # 0 | Software trigger selected.
        # 1 | Hardware trigger selected.
        reg.bit 6, :adtrg
        # Compare Function Enable
        # 
        # 0 | Compare function disabled.
        # 1 | Compare function enabled.
        reg.bit 5, :acfe
        # Compare Function Greater Than
        # 						Enable
        # 
        # 0 | Configures less than threshold, outside range not inclusive and inside range not inclusive; functionality based on the values placed in CV1 and CV2.
        # 1 | Configures greater than or equal to threshold, outside and inside ranges inclusive; functionality based on the values placed in CV1 and CV2.
        reg.bit 4, :acfgt
        # Compare Function Range
        # 						Enable
        # 
        # 0 | Range function disabled. Only CV1 is compared. \{27}
        # 1 | Range function enabled. Both CV1 and CV2 are compared. \{27}
        reg.bit 3, :acren
        # DMA Enable
        # 
        # 0 | DMA is disabled.
        # 1 | DMA is enabled and will assert the ADC DMA request during an ADC conversion complete event noted when any of the SC1n\[COCO\] flags is asserted.
        reg.bit 2, :dmaen
        # Voltage Reference Selection
        # 
        # 0 | Default voltage reference pin pair, that is, external pins VREFH and VREFL
        # 1 | Alternate reference pair, that is, VALTH and VALTL . This pair may be additional external pins or internal sources depending on the MCU configuration. See the chip configuration information for details specific to this MCU
        # 1010 | Internal bandgap reference and associated ground reference (V BGH and V BGL ). Consult the Chip Configuration information for details specific to this MCU. Reserved
        # 1011 | Reserved - Selects default voltage reference (V REFH and V REFL ) pin pair.
        reg.bit 1..0, :refsel
      end
      # Status and Control Register 3
      model.add_reg :sc3, 0x24, size: 32  do |reg|
        # Calibration
        reg.bit 7, :cal
        # Calibration Failed Flag
        # 
        # 0 | Calibration completed normally.
        # 1 | Calibration failed. ADC accuracy specifications are not guaranteed.
        reg.bit 6, :calf
        # Assist Trigger Enable
        # 
        # 0 | Writes to ADCSC1 COCO bit don\'t have an affect on ADTRG.
        # 1 | Writes to ADCSC1 COCO bit will be reflected into ADTRG register. Note: When ASSITRGEN is set, writes to ADCSC1 are delayed by 1/2 bus cycle to allow ADCSC1 COCO write to be updated in ADTRG register so conversion type can be correctly generated (software if coco write is 1\'b0 causing ADTRG to clear or hardware type if coco write is 1\'b1.). Note: User must ensure no hardware trigger is generated between the time ADCSC1 COCO bit is written if value of ADTRG will change to guarantee correct conversion type is generated.
        reg.bit 4, :assitrgen
        # Continuous Conversion
        # 						Enable
        # 
        # 0 | One conversion or one set of conversions if the hardware average function is enabled, that is, AVGE=1, after initiating a conversion.
        # 1 | Continuous conversions or sets of conversions if the hardware average function is enabled, that is, AVGE=1, after initiating a conversion.
        reg.bit 3, :adco
        # Hardware Average Enable
        # 
        # 0 | Hardware average function disabled.
        # 1 | Hardware average function enabled.
        reg.bit 2, :avge
        # Hardware Average Select
        # 
        # 0 | 4 samples averaged.
        # 1 | 8 samples averaged.
        # 1010 | 16 samples averaged.
        # 1011 | 32 samples averaged.
        reg.bit 1..0, :avgs
      end
      # ADC Offset Correction Register
      model.add_reg :ofs, 0x28, size: 32  do |reg|
        # Offset Error Correction
        # 						Value
        reg.bit 15..0, :ofs, reset: 0x4
      end
      # ADC Plus-Side Gain Register
      model.add_reg :pg, 0x2C, size: 32  do |reg|
        # Plus-Side Gain
        reg.bit 15..0, :pg, reset: 0x8200
      end
      # ADC Minus-Side Gain Register
      model.add_reg :mg, 0x30, size: 32  do |reg|
        # Minus-Side Gain
        reg.bit 15..0, :mg, reset: 0x8200
      end
      # ADC Plus-Side General Calibration Value 						Register
      model.add_reg :clpd, 0x34, size: 32  do |reg|
        # Calibration Value
        reg.bit 5..0, :clpd, reset: 0xA
      end
      # ADC Plus-Side General Calibration Value 						Register
      model.add_reg :clps, 0x38, size: 32  do |reg|
        # Calibration Value
        reg.bit 5..0, :clps, reset: 0x20
      end
      # ADC Plus-Side General Calibration Value 						Register
      model.add_reg :clp4, 0x3C, size: 32  do |reg|
        # Calibration Value
        reg.bit 9..0, :clp4, reset: 0x200
      end
      # ADC Plus-Side General Calibration Value 						Register
      model.add_reg :clp3, 0x40, size: 32  do |reg|
        # Calibration Value
        reg.bit 8..0, :clp3, reset: 0x100
      end
      # ADC Plus-Side General Calibration Value 						Register
      model.add_reg :clp2, 0x44, size: 32  do |reg|
        # Calibration Value
        reg.bit 7..0, :clp2, reset: 0x80
      end
      # ADC Plus-Side General Calibration Value 						Register
      model.add_reg :clp1, 0x48, size: 32  do |reg|
        # Calibration Value
        reg.bit 6..0, :clp1, reset: 0x40
      end
      # ADC Plus-Side General Calibration Value 						Register
      model.add_reg :clp0, 0x4C, size: 32  do |reg|
        # Calibration Value
        reg.bit 5..0, :clp0, reset: 0x20
      end
      # ADC Minus-Side General Calibration Value 						Register
      model.add_reg :clmd, 0x54, size: 32  do |reg|
        # Calibration Value
        reg.bit 5..0, :clmd, reset: 0xA
      end
      # ADC Minus-Side General Calibration Value 						Register
      model.add_reg :clms, 0x58, size: 32  do |reg|
        # Calibration Value
        reg.bit 5..0, :clms, reset: 0x20
      end
      # ADC Minus-Side General Calibration Value 						Register
      model.add_reg :clm4, 0x5C, size: 32  do |reg|
        # Calibration Value
        reg.bit 9..0, :clm4, reset: 0x200
      end
      # ADC Minus-Side General Calibration Value 						Register
      model.add_reg :clm3, 0x60, size: 32  do |reg|
        # Calibration Value
        reg.bit 8..0, :clm3, reset: 0x100
      end
      # ADC Minus-Side General Calibration Value 						Register
      model.add_reg :clm2, 0x64, size: 32  do |reg|
        # Calibration Value
        reg.bit 7..0, :clm2, reset: 0x80
      end
      # ADC Minus-Side General Calibration Value 						Register
      model.add_reg :clm1, 0x68, size: 32  do |reg|
        # Calibration Value
        reg.bit 6..0, :clm1, reset: 0x40
      end
      # ADC Minus-Side General Calibration Value 						Register
      model.add_reg :clm0, 0x6C, size: 32  do |reg|
        # Calibration Value
        reg.bit 5..0, :clm0, reset: 0x20
      end
    end
  end
end
# rubocop:enable all
